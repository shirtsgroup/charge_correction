"""
~=~=~=~=~=~=~=~=~=~=~ Charge Correction Solver ~=~=~=~=~=~=~=~=~=~=~
Solves for MD charge corrections as described in:
"Calculating the binding free energies of charged species based on
explicit-solvent simulations employing lattice-sum methods: An
accurate correction scheme for electrostatic finite-size effects" by
GJ Rocklin et al.
"""
import math


# defining the vacuum permittivity in correct units
ep0 = 0.000572765876174  # e^2 * mol / kJ * nm


def g_net(q_l, q_p, l, xi_ls):
    """Calculates `dg_net` using equation 15 from GJ Rocklin et al.
    Parameters
    ----------
    q_l : float
        The net charge of the ligand (e).
    q_p : float
        The net charge of the protein (e).
    l : float
        The box length (nm).
    xi_ls : float
        The cubic lattice-sum (Wigner) integration constant (unitless). Use -2.837297 for a cubic box.
    Returns
    -------
    dg_net : float
        Correction for periodicity-induced net-charge interactions.
    """
    dg_net = (-xi_ls / (8 * math.pi * ep0)) * ((q_p + q_l) ** 2 - q_p ** 2) * (1 / l)

    return dg_net


def g_usv(q_l, q_p, l, xi_ls, eps):
    """Calculates `dg_usv` using equation 16 from GJ Rocklin et al.
    Parameters
    ----------
    q_l : float
        The net charge of the ligand (e).
    q_p : float
        The net charge of the protein (e).
    l : float
        The box length (nm).
    xi_ls : float
        The cubic lattice-sum (Wigner) integration constant (unitless). Use -2.837297 for a cubic box.
    eps : float
        solvent permittivity ratio to vacuum permittivity (unitless). Use 97 for TIP3P water model.
    Returns
    -------
    dg_usv : float
        Correction for periodicity-induced undersolvation.
    """
    dg_usv = (xi_ls / (8 * math.pi * ep0)) * (1 - (1 / eps)) * ((q_p + q_l) ** 2 - q_p ** 2) * (1 / l)

    return dg_usv


def g_dsc(gamma_s, rho_s, m_s, n_s, q_l, l):
    """Calculates `dg_dsc` using equations 30 and 34 from GJ Rocklin et al.
    Parameters
    ----------
    gamma_s : float
        The quadrupole-moment trace of the solvent model relative to its single Waals interaction site (e * nm^2).
        See equation 29 of GJ Rocklin et al. Use 0.0764 for TIP3P.
    rho_s : float
        The density of the water model used (units mass / nm^3).
    m_s : float
        The molecular mass of the water model used (units mass / molecule).
    n_s : float
        The number of solvent molecules used (molecules).
    q_l : float
        The net charge of the ligand (e).
    l : float
        The box length (nm).
    Returns
    -------
    dg_dsc : float
        Correction for discrete solvent effects.
    """

    # determining solute excluded volume
    v_c = l ** 3 - n_s * m_s / rho_s

    dg_dsi = - gamma_s * rho_s * q_l / 6 / ep0 / m_s
    dg_dsf = - dg_dsi * v_c / l ** 3

    dg_dsc = dg_dsi + dg_dsf

    return dg_dsc


def g_rip(i_p, i_l, q_p, q_l, l):
    """Calculates `dg_rip` using equation 17 from GJ Rocklin et al.
    Parameters
    ----------
    i_p : float
        The protein residual integrated potential (kJ nm^3/(mol e)).
    i_l : float
        The ligand residual integrated potential (kJ nm^3/(mol e)).
    q_l : float
        The net charge of the ligand (e).
    q_p : float
        The net charge of the protein (e).
    l : float
        The box length (nm).
    Returns
    -------
    dg_rip : float
        Correction for residual integrated potential.
    """

    dg_rip = ((i_p + i_l) * (q_p + q_l) - i_p * q_p) * (1.0 / (l ** 3.0))

    return dg_rip


def g_emp(q_p, q_l, l, i_lslv, eps):
    """Calculates `dg_emp` using equations 26 and 25 from GJ Rocklin et al.
    Parameters
    ----------
    q_l : float
        The net charge of the ligand (e).
    q_p : float
        The net charge of the protein (e).
    l : float
        The box length (nm).
    i_lslv : float
        The solvation contribution to hte residual integrated potential (kJ nm^3/(mol e)).
    eps : float
        solvent permittivity ratio to vacuum permittivity (unitless). Use 97 for TIP3P water model.
    Returns
    -------
    dg_rip : float
        Correction for empirical correction.
    """

    # calculating the effective radius of the ligand
    r_l = math.sqrt(((1 / (6 * ep0)) * (1 - (1 / eps)) * q_l) ** (-1) * i_lslv)

    dg_emp = (-(2 * math.pi) / (45 * ep0)) * (1 - (1 / eps)) * ((q_p + q_l) ** 2 - q_p ** 2) * ((r_l ** 5) / (l ** 6))

    return dg_emp


def rip(eps, T, dxfile, netq):
    """Calculates `i` using equation 18 from GJ Rocklin et al.
    Parameters
    ----------
    eps : float
        solvent permittivity ratio to vacuum permittivity (unitless). Use 97 for TIP3P water model.
    T : float
        The system temperature (K).
    dxfile : str
        The dx file generated by APBS.
    netq : float
        The total system charge (e).
    Returns
    -------
    i : float
        The residual integrated potential.
    """
    # physical constants
    coulomb_factor = 138.93545585  # (4*pi*eps_0)**-1 in (kJ nm)/(e**2 mol)
    kB = 0.0083144621  # kJ/(mol K)
    kBT = kB * T
    xi_cb = 2.38008

    # read the APBS potential map
    file = open(dxfile)
    lines = file.readlines()
    file.close()

    # extract information from the dx file
    #
    # gap: the space between grid points, determined based on the x axis.
    # this assumes the grid is evenly spaced in all directions.
    gap = float(lines[6].split()[1])

    # eliminate headers and other non-data lines from dx file
    lines = filter(lambda x: x[0] in '0123456789-.', lines)

    # initialize variables to store the total potential
    # and the number of grid points
    tot_pot = 0.0
    numpts = 0

    # add the potential on every line
    # and add that number of grid points
    for line in lines:
        tot_pot += sum([float(x) for x in line.split()])
        numpts += len(line.split())

    # checking if tot_pot is nan (happens sometimes if file is empty)
    if math.isnan(tot_pot):
        print('Total potential of %s is NaN, setting to zero' % dxfile)
        tot_pot = 0

    # calculate the volume in nm^3
    v = (((gap ** 3) / 1000.0) * numpts)

    # convert the total potential to kJ nm^3 / (mol e) from kBT (gap^2) / (mol e)
    # label this as B for box integral, X because it refers to the system X.
    # See eq. (19) in paper.
    b_x = tot_pot * kBT * v / numpts

    # calculate the expected total potential based on the net charge
    # label this as B for box integral, QX because it refers to net charge Q (same Q as system X)
    # See eq. (20) in paper.
    b_qx = (netq * xi_cb * coulomb_factor / eps * (v ** (2.0 / 3.0)))

    # calculate the RIP
    # See Eq. (18) in paper.
    i = b_x - b_qx

    return i


def total_correction(q_p, q_l, n_s, l, T, model, dx_p, dx_l, dx_ls):
    """Calculates `dg` using equations from GJ Rocklin et al.
    Parameters
    ----------
    q_p : float
        The net charge of the protein (e).
    q_l : float
        The net charge of the ligand (e).
    n_s : float
        The number of solvent molecules used (molecules).
    l : float
        The box length (nm).
    T : float
        The system temperature (K).
    model : str
        The water model used. Currently only works for TIP3P.
    dx_p : str
        The path to the APBS generated protein dx file.
    dx_l : str
        The path to the APBS generated ligand dx file.
    dx_ls : str
        The path to the APBS generated ligand solvent dx file.
    Returns
    -------
    dg_net : float
        Correction for periodicity-induced net-charge interactions.
    dg_usv : float
        Correction for periodicity-induced undersolvation.
    dg_dsc : float
        Correction for discrete solvent effects.
    dg_rip : float
        Correction for residual integrated potential.
    dg_total : float
        The total charge correction factor.
    """

    # need to make a dictionary for these based on model (todo)
    eps = 97.0
    xi_ls = -2.837397
    gamma_s = 0.00764
    rho_s = 1.002 / (10 ** 7) ** 3
    m_s = 18 / (6.0221409 * 10 ** 23)

    # calculating the residual integrated potential for each dx file
    i_p = rip(eps, T, dx_p, q_p)
    i_l = rip(eps, T, dx_l, q_l)
    i_ls = rip(1.0, T, dx_ls, q_l)  # see ... (todo)

    # calculating the correction for periodicity-induced net-charge interactions
    dg_net = g_net(q_l, q_p, l, xi_ls)

    # calculating the correction for periodicity-induced undersolvation
    dg_usv = g_usv(q_l, q_p, l, xi_ls, eps)

    # calculating the correction for discrete solvent effects
    dg_dsc = g_dsc(gamma_s, rho_s, m_s, n_s, q_l, l)

    # calculating the correction for residual integrated potential
    dg_rip = g_rip(i_p, i_l, q_p, q_l, l)

    # calculating the empirical correction
    i_lslv = i_l - i_ls
    dg_emp = g_emp(q_p, q_l, l, i_lslv, eps)

    # summing the terms
    dg_total = dg_net + dg_usv + dg_dsc + dg_rip + dg_emp

    # printing to screen
    print('(delta)G_{NET}=' + str(dg_net) + ' kJ/mol')
    print('(delta)G_{USV}=' + str(dg_usv) + ' kJ/mol')
    print('(delta)G_{RIP}=' + str(dg_rip) + ' kJ/mol')
    print('(delta)G_{EMP}=' + str(dg_emp) + ' kJ/mol')
    print('(delta)G_{DSC}=' + str(dg_dsc) + ' kJ/mol')
    print('=======================')
    print('(delta)G_{TOTAL}=' + str(dg_total) + ' kJ/mol')
    print(' ')

    return dg_net, dg_usv, dg_dsc, dg_rip, dg_total
